name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  release:
    types: [published]

env:
  GO_VERSION: '1.24'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'

      - name: Install dependencies and generate manifests
        run: |
          make manifests

      - name: Environment preparation
        run: |
          echo "Performing environment preparation..."
          # Clean up any local test artifacts
          rm -rf test-results/ coverage/ logs/ tmp/
          echo "Environment preparation completed"

      - name: Run unit tests with race detection
        run: |
          echo "Running unit tests with race detection..."
          make test-unit
        timeout-minutes: 15

      - name: Run tests that don't require a cluster
        run: |
          echo "Running all tests that don't require a cluster..."
          make test-no-cluster
        timeout-minutes: 10

      - name: Cleanup test environment
        if: always()
        run: |
          echo "Performing test environment cleanup..."
          if [ -f "scripts/test-cleanup.sh" ]; then
            chmod +x scripts/test-cleanup.sh
            export AGGRESSIVE_CLEANUP=true
            export FORCE_CLEANUP=true
            ./scripts/test-cleanup.sh cleanup || echo "Cleanup completed with warnings"
          fi

  integration-test:
    name: Integration Test
    runs-on: ubuntu-latest
    needs: [test]
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Environment preparation
        run: |
          echo "Performing environment preparation..."
          # Clean up any local test artifacts
          rm -rf test-results/ coverage/ logs/ tmp/
          echo "Environment preparation completed"

      - name: Install dependencies and generate manifests
        run: |
          make manifests

      - name: Create Kind Cluster
        run: |
          echo "=== Creating Kind cluster with simple configuration ==="

          # Clean up any existing cluster first
          kind delete cluster --name neo4j-operator-test 2>/dev/null || true

          # Create cluster with simple configuration (proven to work)
          if kind create cluster --name neo4j-operator-test --config hack/kind-config-simple.yaml --image kindest/node:v1.30.0 --wait 10m; then
            echo "✅ Cluster created successfully with simple configuration"
            echo "CLUSTER_CREATED=true" >> $GITHUB_ENV
            echo "CLUSTER_CONFIG=simple configuration" >> $GITHUB_ENV
          else
            echo "❌ Simple configuration failed, trying minimal cluster without config"

            # Fallback to minimal cluster without configuration
            if kind create cluster --name neo4j-operator-test --image kindest/node:v1.30.0 --wait 10m; then
              echo "✅ Cluster created successfully with minimal configuration"
              echo "CLUSTER_CREATED=true" >> $GITHUB_ENV
              echo "CLUSTER_CONFIG=minimal configuration" >> $GITHUB_ENV
            else
              echo "❌ All cluster creation attempts failed"
              echo "=== Debugging information ==="
              echo "Docker containers:"
              docker ps -a
              echo "Docker system info:"
              docker system df
              echo "Available memory:"
              free -h || echo "free command not available"
              echo "Available disk space:"
              df -h || echo "df command not available"
              echo "Kind version:"
              kind version || echo "Cannot get Kind version"
              echo "Docker version:"
              docker version || echo "Cannot get Docker version"
              echo "=== End debugging ==="
              exit 1
            fi
          fi

          echo "=== Cluster creation completed successfully ==="

      - name: Configure kubectl context
        run: |
          echo "=== Configuring kubectl context ==="

          # Export kubeconfig from kind
          kind export kubeconfig --name neo4j-operator-test

          # Set KUBECONFIG environment variable
          export KUBECONFIG=$(kind export kubeconfig --name neo4j-operator-test)
          echo "KUBECONFIG=$KUBECONFIG" >> $GITHUB_ENV

          # Verify kubectl can connect
          kubectl cluster-info || (echo "❌ kubectl cannot connect to cluster" && exit 1)
          echo "✅ kubectl context configured successfully"

          echo "=== kubectl context configuration completed ==="

      - name: Debug cluster creation
        if: failure()
        run: |
          echo "=== Debugging cluster creation failure ==="
          echo "Docker containers:"
          docker ps -a
          echo "Docker logs for control plane:"
          docker logs neo4j-operator-test-control-plane || echo "Container not found"
          echo "Kind cluster status:"
          kind get clusters
          echo "Kubeconfig:"
          kind export kubeconfig --name neo4j-operator-test || echo "Failed to export kubeconfig"
          echo "=== End debugging ==="

      - name: Verify cluster health
        run: |
          echo "=== Verifying cluster health ==="

          # Wait for cluster to be ready
          kubectl wait --for=condition=ready node --all --timeout=300s || echo "Node readiness check failed"

          # Check cluster status
          kubectl get nodes -o wide
          kubectl get pods -n kube-system

          # Verify core components are running
          kubectl get pods -n kube-system | grep -E "(coredns|kube-apiserver|kube-controller-manager|kube-scheduler)" || echo "Some core components not found"

          echo "✅ Cluster health verification completed"
          echo "CLUSTER_HEALTHY=true" >> $GITHUB_ENV

      - name: Build operator image
        run: |
          echo "=== Building operator image ==="

          # Check if cluster is healthy
          if [[ "${CLUSTER_HEALTHY:-false}" != "true" ]]; then
            echo "❌ Cluster is not healthy, skipping image build"
            exit 0
          fi

          # Build the operator image
          make docker-build IMG=neo4j-operator:ci

          # Load the image into Kind cluster
          kind load docker-image neo4j-operator:ci --name neo4j-operator-test

          echo "✅ Operator image built and loaded"

      - name: Verify operator image
        run: |
          echo "=== Verifying operator image ==="

          # Check if cluster is healthy
          if [[ "${CLUSTER_HEALTHY:-false}" != "true" ]]; then
            echo "❌ Cluster is not healthy, skipping image verification"
            exit 0
          fi

          # Check if image exists in Docker
          if ! docker images | grep -q "neo4j-operator.*ci"; then
            echo "❌ Operator image not found in Docker"
            exit 1
          fi

          # Check if image is loaded in Kind cluster
          if ! docker exec neo4j-operator-test-control-plane crictl images | grep -q "neo4j-operator"; then
            echo "❌ Operator image not loaded in Kind cluster"
            echo "Available images in Kind cluster:"
            docker exec neo4j-operator-test-control-plane crictl images
            exit 1
          fi

          echo "✅ Operator image verified"

      - name: Prepare operator namespace
        run: |
          echo "=== Preparing operator namespace ==="

          # Check if cluster is healthy
          if [[ "${CLUSTER_HEALTHY:-false}" != "true" ]]; then
            echo "❌ Cluster is not healthy, skipping namespace preparation"
            exit 0
          fi

          # Create namespace if it doesn't exist
          kubectl create namespace neo4j-operator-system --dry-run=client -o yaml | kubectl apply -f -

          # Verify namespace exists
          if kubectl get namespace neo4j-operator-system >/dev/null 2>&1; then
            echo "✅ Operator namespace ready"
          else
            echo "❌ Failed to create operator namespace"
            exit 1
          fi

      - name: Deploy operator
        run: |
          echo "=== Deploying operator ==="

          # Check if cluster is healthy
          if [[ "${CLUSTER_HEALTHY:-false}" != "true" ]]; then
            echo "❌ Cluster is not healthy, skipping operator deployment"
            echo "OPERATOR_READY=false" >> $GITHUB_ENV
            exit 0
          fi

          # Deploy the operator with webhooks disabled for CI
          make deploy-ci IMG=neo4j-operator:ci

          # Wait for operator to be ready
          kubectl wait --for=condition=available deployment/neo4j-operator-controller-manager -n neo4j-operator-system --timeout=300s || echo "Operator deployment timeout"

          # Check operator status
          kubectl get pods -n neo4j-operator-system
          kubectl get deployment neo4j-operator-controller-manager -n neo4j-operator-system

          # Verify operator is ready
          if kubectl get deployment neo4j-operator-controller-manager -n neo4j-operator-system -o jsonpath='{.status.readyReplicas}' | grep -q "1"; then
            echo "✅ Operator is ready"
            echo "OPERATOR_READY=true" >> $GITHUB_ENV
          else
            echo "⚠️  Operator is not ready"
            echo "OPERATOR_READY=false" >> $GITHUB_ENV
          fi

          # Verify CRDs are installed
          echo "Verifying CRDs are installed..."
          kubectl get crd | grep neo4j.neo4j.com

          echo "✅ Operator deployment completed"

      - name: Debug operator deployment on failure
        if: failure() && env.CLUSTER_HEALTHY == 'true'
        run: |
          echo "=== Debugging operator deployment failure ==="

          echo "Cluster nodes:"
          kubectl get nodes -o wide

          echo "All pods in neo4j-operator-system:"
          kubectl get pods -n neo4j-operator-system -o wide

          echo "Operator deployment details:"
          kubectl describe deployment neo4j-operator-controller-manager -n neo4j-operator-system || echo "Deployment not found"

          echo "Operator pod details:"
          kubectl get pods -n neo4j-operator-system -l app=neo4j-operator-controller-manager -o name | head -1 | xargs -r kubectl describe -n neo4j-operator-system || echo "No operator pods found"

          echo "Operator pod logs:"
          kubectl logs -n neo4j-operator-system -l app=neo4j-operator-controller-manager --tail=100 || echo "No operator logs found"

          echo "Events in neo4j-operator-system namespace:"
          kubectl get events -n neo4j-operator-system --sort-by='.lastTimestamp' | tail -20 || echo "No events found"

          echo "All deployments in neo4j-operator-system:"
          kubectl get deployments -n neo4j-operator-system

          echo "All services in neo4j-operator-system:"
          kubectl get services -n neo4j-operator-system

          echo "=== End operator deployment debugging ==="

      - name: Run integration tests
        run: |
          echo "Running integration tests..."

          # Check if cluster is healthy
          if [[ "${CLUSTER_HEALTHY:-false}" != "true" ]]; then
            echo "❌ Cluster is not healthy, cannot run integration tests"
            exit 1
          fi

          # Check if operator is ready
          if [[ "${OPERATOR_READY:-false}" != "true" ]]; then
            echo "❌ Operator is not ready, cannot run integration tests"
            exit 1
          fi

          # Set up test environment
          export KUBECONFIG=$(kind export kubeconfig --name neo4j-operator-test)

          # Clean up any existing test namespaces to prevent conflicts
          echo "Cleaning up existing test namespaces..."
          kubectl get namespaces --no-headers -o custom-columns="NAME:.metadata.name" | grep -E "^(test-)" | xargs -r kubectl delete namespace --force --grace-period=0 || echo "No existing test namespaces found"

          # Wait for cleanup to complete
          sleep 10

          # Verify test environment
          echo "Verifying test environment..."
          kubectl get nodes
          kubectl get pods -n neo4j-operator-system
          kubectl get crd | grep neo4j.neo4j.com

          # Run integration tests
          make test-integration
        timeout-minutes: 15

      - name: Debug integration test failure
        if: failure() && env.CLUSTER_HEALTHY == 'true' && env.OPERATOR_READY == 'true'
        run: |
          echo "=== Debugging integration test failure ==="

          echo "Cluster status:"
          kubectl get nodes -o wide

          echo "Operator status:"
          kubectl get pods -n neo4j-operator-system -o wide
          kubectl logs -n neo4j-operator-system -l app=neo4j-operator-controller-manager --tail=50 || echo "No operator logs"

          echo "CRDs status:"
          kubectl get crd | grep neo4j.neo4j.com

          echo "Test namespaces:"
          kubectl get namespaces | grep -E "(test-|gke-|aks-|eks-)" || echo "No test namespaces found"

          echo "Recent events:"
          kubectl get events --all-namespaces --sort-by='.lastTimestamp' | tail -20 || echo "No events found"

          echo "=== End integration test debugging ==="

      - name: Run e2e tests
        run: |
          echo "Running e2e tests..."

          # Check if cluster is healthy
          if [[ "${CLUSTER_HEALTHY:-false}" != "true" ]]; then
            echo "❌ Cluster is not healthy, cannot run e2e tests"
            exit 1
          fi

          # Set up test environment
          export KUBECONFIG=$(kind export kubeconfig --name neo4j-operator-test)

          # Run e2e tests
          make test-e2e
        timeout-minutes: 10

      - name: Cleanup
        if: always()
        run: |
          echo "=== Cleaning up test environment ==="

          # Clean up Kind cluster
          kind delete cluster --name neo4j-operator-test || echo "Cluster cleanup failed"

          # Clean up Docker resources
          docker system prune -f || echo "Docker cleanup failed"

          echo "=== Cleanup completed ==="

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [test, integration-test]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      - name: Build
        run: make build
      - name: Build container image
        run: make docker-build
      - name: Log in to Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata
        if: github.event_name != 'pull_request'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha
      - name: Build and push Docker image
        if: github.event_name != 'pull_request'
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: [test]
    steps:
      - uses: actions/checkout@v4
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
      - name: Run Gosec Security Scanner
        run: |
          go install github.com/securego/gosec/v2/cmd/gosec@latest
          gosec -no-fail -fmt sarif -out results.sarif ./...
        continue-on-error: true
      - name: Ensure SARIF file exists
        run: |
          if [ ! -f results.sarif ]; then
            echo '{"version":"2.1.0","runs":[]}' > results.sarif
          fi
      - name: Upload SARIF file
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: results.sarif
        if: always()

  release:
    name: Release
    runs-on: ubuntu-latest
    needs: [integration-test, build]
    if: github.event_name == 'release'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      - name: Run GoReleaser
        uses: goreleaser/goreleaser-action@v5
        with:
          version: latest
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
