#!/bin/bash
set -euo pipefail

# Neo4j Operator Development Environment Manager
# This script provides a comprehensive set of tools for enhancing the developer experience

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
DEV_CONFIG_FILE="${PROJECT_ROOT}/.dev-config"

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_debug() {
    echo -e "${PURPLE}[DEBUG]${NC} $1"
}

log_header() {
    echo -e "${CYAN}==== $1 ====${NC}"
}

# Load configuration
load_config() {
    if [[ -f "${DEV_CONFIG_FILE}" ]]; then
        source "${DEV_CONFIG_FILE}"
    fi
}

# Save configuration
save_config() {
    cat > "${DEV_CONFIG_FILE}" << EOF
# Neo4j Operator Development Configuration
# This file is automatically generated and managed by dev-environment.sh

# Development Mode Settings
DEV_MODE=${DEV_MODE:-development}
DEBUG_ENABLED=${DEBUG_ENABLED:-false}
HOT_RELOAD_ENABLED=${HOT_RELOAD_ENABLED:-false}
PROFILING_ENABLED=${PROFILING_ENABLED:-false}

# Cluster Settings
CLUSTER_NAME=${CLUSTER_NAME:-neo4j-operator-dev}
CLUSTER_NAMESPACE=${CLUSTER_NAMESPACE:-default}
CLUSTER_CONTEXT=${CLUSTER_CONTEXT:-kind-neo4j-operator-dev}

# Port Settings
METRICS_PORT=${METRICS_PORT:-8080}
HEALTH_PORT=${HEALTH_PORT:-8081}
WEBHOOK_PORT=${WEBHOOK_PORT:-9443}
PPROF_PORT=${PPROF_PORT:-6060}

# Feature Flags
WEBHOOKS_ENABLED=${WEBHOOKS_ENABLED:-false}
TLS_ENABLED=${TLS_ENABLED:-true}
RBAC_ENABLED=${RBAC_ENABLED:-true}
OBSERVABILITY_ENABLED=${OBSERVABILITY_ENABLED:-true}

# Tool Settings
EDITOR=${EDITOR:-code}
BROWSER=${BROWSER:-open}
TERMINAL=${TERMINAL:-}

# Export timestamp
LAST_UPDATED=$(date -u +%Y-%m-%dT%H:%M:%SZ)
EOF
    log_success "Configuration saved to ${DEV_CONFIG_FILE}"
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Development dashboard
show_dashboard() {
    load_config

    echo -e "${CYAN}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                     Neo4j Operator Development Dashboard                     â•‘"
    echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
    echo -e "â•‘ ${NC}Project: Neo4j Enterprise Operator for Kubernetes${CYAN}                      â•‘"
    echo -e "â•‘ ${NC}Mode: ${DEV_MODE:-development}${CYAN}                                                        â•‘"
    echo -e "â•‘ ${NC}Cluster: ${CLUSTER_NAME:-neo4j-operator-dev}${CYAN}                                            â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"

    echo -e "${BLUE}ðŸ“Š Current Status:${NC}"

    # Check cluster status
    if kubectl cluster-info --context="${CLUSTER_CONTEXT:-kind-neo4j-operator-dev}" >/dev/null 2>&1; then
        echo -e "  ${GREEN}âœ“${NC} Kubernetes cluster is accessible"

        # Check if CRDs are installed
        if kubectl get crd neo4jenterpriseclusters.neo4j.neo4j.com >/dev/null 2>&1; then
            echo -e "  ${GREEN}âœ“${NC} Neo4j CRDs are installed"
        else
            echo -e "  ${YELLOW}âš ${NC} Neo4j CRDs not installed"
        fi

        # Check if operator is running
        if kubectl get deployment neo4j-operator-controller-manager -n neo4j-operator-system >/dev/null 2>&1; then
            echo -e "  ${GREEN}âœ“${NC} Operator is deployed"
        else
            echo -e "  ${YELLOW}âš ${NC} Operator not deployed"
        fi
    else
        echo -e "  ${RED}âœ—${NC} Kubernetes cluster not accessible"
    fi

    # Check development tools
    echo -e "${BLUE}ðŸ”§ Development Tools:${NC}"

    local tools=("go" "docker" "kubectl" "kind" "helm" "tilt" "air" "dlv" "golangci-lint")
    for tool in "${tools[@]}"; do
        if command_exists "$tool"; then
            echo -e "  ${GREEN}âœ“${NC} $tool"
        else
            echo -e "  ${RED}âœ—${NC} $tool"
        fi
    done

    echo -e "${BLUE}ðŸš€ Quick Actions:${NC}"
    echo "  $0 init       - Initialize development environment"
    echo "  $0 start      - Start development environment"
    echo "  $0 stop       - Stop development environment"
    echo "  $0 restart    - Restart development environment"
    echo "  $0 logs       - View operator logs"
    echo "  $0 test       - Run tests"
    echo "  $0 debug      - Start debugging session"
    echo "  $0 clean      - Clean development environment"
    echo "  $0 config     - Configure development settings"
    echo "  $0 tools      - Install/update development tools"
}

# Initialize development environment
init_dev_env() {
    log_header "Initializing Development Environment"

    # Create development directories
    mkdir -p "${PROJECT_ROOT}/"{logs,tmp,coverage,reports,docs/dev}

    # Initialize configuration
    save_config

    # Install development tools
    install_dev_tools

    # Setup git hooks
    setup_git_hooks

    # Create development cluster
    create_dev_cluster

    # Install CRDs
    install_crds

    log_success "Development environment initialized successfully!"
    log_info "Run '$0 dashboard' to see the current status"
}

# Install development tools
install_dev_tools() {
    log_header "Installing Development Tools"

    # Install Go tools
    local go_tools=(
        "golang.org/x/tools/cmd/goimports@latest"
        "github.com/go-delve/delve/cmd/dlv@latest"
        "github.com/air-verse/air@latest"
        "github.com/golangci/golangci-lint/cmd/golangci-lint@latest"
        "github.com/onsi/ginkgo/v2/ginkgo@latest"
        "github.com/securecodewarrior/sast-scan/cmd/sast-scan@latest"
        "github.com/fzipp/gocyclo/cmd/gocyclo@latest"
        "honnef.co/go/tools/cmd/staticcheck@latest"
        "github.com/kisielk/errcheck@latest"
    )

    for tool in "${go_tools[@]}"; do
        log_info "Installing $tool..."
        go install "$tool" || log_warning "Failed to install $tool"
    done

    # Install other tools based on OS
    case "$(uname -s)" in
        Darwin)
            if command_exists brew; then
                brew install --quiet kind helm tilt-dev/tap/tilt 2>/dev/null || true
                brew install --quiet pre-commit yamllint shellcheck 2>/dev/null || true
            fi
            ;;
        Linux)
            # Install kind
            if ! command_exists kind; then
                curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
                chmod +x ./kind
                sudo mv ./kind /usr/local/bin/kind
            fi

            # Install helm
            if ! command_exists helm; then
                curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
            fi
            ;;
    esac

    log_success "Development tools installation completed"
}

# Setup git hooks
setup_git_hooks() {
    log_header "Setting up Git Hooks"

    if command_exists pre-commit; then
        pre-commit install
        pre-commit install --hook-type commit-msg
        log_success "Pre-commit hooks installed"
    else
        log_warning "pre-commit not found, skipping git hooks setup"
    fi
}

# Create development cluster
create_dev_cluster() {
    log_header "Creating Development Cluster"

    if kind get clusters | grep -q "${CLUSTER_NAME}"; then
        log_info "Development cluster already exists"
        return
    fi

    # Create cluster with custom configuration
    kind create cluster --name "${CLUSTER_NAME}" --config "${PROJECT_ROOT}/hack/kind-config.yaml"

    # Wait for cluster to be ready
    kubectl wait --for=condition=ready node --all --timeout=300s

    # Install cert-manager
    log_info "Installing cert-manager..."
    kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml
    kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=cert-manager -n cert-manager --timeout=300s

    # Install Prometheus if observability is enabled
    if [[ "${OBSERVABILITY_ENABLED:-true}" == "true" ]]; then
        install_monitoring_stack
    fi

    log_success "Development cluster created successfully"
}

# Install monitoring stack
install_monitoring_stack() {
    log_info "Installing monitoring stack..."

    # Add Prometheus Helm repository
    helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
    helm repo update

    # Install kube-prometheus-stack
    helm upgrade --install prometheus prometheus-community/kube-prometheus-stack \
        --namespace monitoring \
        --create-namespace \
        --set prometheus.prometheusSpec.serviceMonitorSelectorNilUsesHelmValues=false \
        --set prometheus.prometheusSpec.podMonitorSelectorNilUsesHelmValues=false \
        --wait || log_warning "Failed to install monitoring stack"

    log_success "Monitoring stack installed"
}

# Install CRDs
install_crds() {
    log_header "Installing CRDs"

    cd "${PROJECT_ROOT}"
    make install

    log_success "CRDs installed successfully"
}

# Start development environment
start_dev_env() {
    log_header "Starting Development Environment"

    load_config

    # Ensure cluster is running
    if ! kubectl cluster-info --context="${CLUSTER_CONTEXT}" >/dev/null 2>&1; then
        log_error "Cluster not accessible. Run '$0 init' first."
        exit 1
    fi

    # Start based on mode
    case "${DEV_MODE:-development}" in
        "debug")
            start_debug_mode
            ;;
        "hot-reload")
            start_hot_reload_mode
            ;;
        "tilt")
            start_tilt_mode
            ;;
        *)
            start_normal_mode
            ;;
    esac
}

# Start normal development mode
start_normal_mode() {
    log_info "Starting in normal development mode..."

    cd "${PROJECT_ROOT}"

    # Build and run the operator
    go run cmd/main.go \
        --zap-devel=true \
        --zap-log-level=debug \
        --leader-elect=false \
        --metrics-bind-address=":${METRICS_PORT}" \
        --health-probe-bind-address=":${HEALTH_PORT}" \
        2>&1 | tee "logs/operator-$(date +%Y%m%d-%H%M%S).log"
}

# Start debug mode
start_debug_mode() {
    log_info "Starting in debug mode..."

    cd "${PROJECT_ROOT}"

    # Build with debug symbols
    go build -gcflags="all=-N -l" -o tmp/manager cmd/main.go

    # Start with delve
    dlv exec tmp/manager --listen=:2345 --headless=true --api-version=2 -- \
        --zap-devel=true \
        --zap-log-level=debug \
        --leader-elect=false \
        --pprof-bind-address=":${PPROF_PORT}"
}

# Start hot reload mode
start_hot_reload_mode() {
    log_info "Starting in hot reload mode..."

    cd "${PROJECT_ROOT}"

    # Create air config if not exists
    if [[ ! -f .air.toml ]]; then
        create_air_config
    fi

    air
}

# Start Tilt mode
start_tilt_mode() {
    log_info "Starting Tilt development environment..."

    cd "${PROJECT_ROOT}"

    # Start Tilt
    tilt up
}

# Create air configuration
create_air_config() {
    cat > "${PROJECT_ROOT}/.air.toml" << 'EOF'
root = "."
testdata_dir = "testdata"
tmp_dir = "tmp"

[build]
  args_bin = [
    "--zap-devel=true",
    "--zap-log-level=debug",
    "--leader-elect=false",
    "--metrics-bind-address=:8080",
    "--health-probe-bind-address=:8081"
  ]
  bin = "./tmp/main"
  cmd = "go build -o ./tmp/main cmd/main.go"
  delay = 1000
  exclude_dir = ["assets", "tmp", "vendor", "testdata", "bin", "config", "logs", "coverage"]
  exclude_file = []
  exclude_regex = ["_test.go"]
  exclude_unchanged = false
  follow_symlink = false
  full_bin = ""
  include_dir = ["cmd", "api", "internal"]
  include_ext = ["go", "tpl", "tmpl", "html"]
  kill_delay = "0s"
  log = "logs/build-errors.log"
  send_interrupt = false
  stop_on_root = false

[color]
  app = ""
  build = "yellow"
  main = "magenta"
  runner = "green"
  watcher = "cyan"

[log]
  time = false

[misc]
  clean_on_exit = true
EOF
}

# View logs
view_logs() {
    load_config

    log_header "Viewing Operator Logs"

    # If running in cluster, show pod logs
    if kubectl get deployment neo4j-operator-controller-manager -n neo4j-operator-system >/dev/null 2>&1; then
        kubectl logs -f deployment/neo4j-operator-controller-manager -n neo4j-operator-system
    else
        # Show local logs
        local log_file=$(ls -t logs/operator-*.log 2>/dev/null | head -1)
        if [[ -n "$log_file" ]]; then
            tail -f "$log_file"
        else
            log_warning "No operator logs found"
        fi
    fi
}

# Run tests
run_tests() {
    log_header "Running Tests"

    cd "${PROJECT_ROOT}"

    case "${1:-unit}" in
        "unit")
            make test-unit
            ;;
        "integration")
            make test-integration
            ;;
        "e2e")
            make test-e2e
            ;;
        "all")
            make test-all
            ;;
        "coverage")
            make coverage
            ;;
        *)
            log_error "Unknown test type: $1"
            log_info "Available types: unit, integration, e2e, all, coverage"
            exit 1
            ;;
    esac
}

# Debug session
debug_session() {
    log_header "Starting Debug Session"

    echo -e "${CYAN}Debug Session Options:${NC}"
    echo "1. Debug operator locally"
    echo "2. Debug running pod"
    echo "3. Port forward to services"
    echo "4. Open monitoring dashboards"
    echo "5. Inspect CRDs and resources"

    read -p "Choose option (1-5): " choice

    case $choice in
        1)
            start_debug_mode
            ;;
        2)
            debug_running_pod
            ;;
        3)
            setup_port_forwards
            ;;
        4)
            open_monitoring_dashboards
            ;;
        5)
            inspect_resources
            ;;
        *)
            log_error "Invalid choice"
            ;;
    esac
}

# Debug running pod
debug_running_pod() {
    local pod=$(kubectl get pods -l app.kubernetes.io/name=neo4j-operator -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)

    if [[ -n "$pod" ]]; then
        log_info "Debugging pod: $pod"
        kubectl exec -it "$pod" -- /bin/sh
    else
        log_error "No operator pod found"
    fi
}

# Setup port forwards
setup_port_forwards() {
    log_info "Setting up port forwards..."

    # Port forward to metrics
    kubectl port-forward deployment/neo4j-operator-controller-manager 8080:8080 &
    echo $! > tmp/pf-metrics.pid

    # Port forward to health
    kubectl port-forward deployment/neo4j-operator-controller-manager 8081:8081 &
    echo $! > tmp/pf-health.pid

    # Port forward to Prometheus
    if kubectl get service prometheus-kube-prometheus-prometheus -n monitoring >/dev/null 2>&1; then
        kubectl port-forward service/prometheus-kube-prometheus-prometheus 9090:9090 -n monitoring &
        echo $! > tmp/pf-prometheus.pid
    fi

    # Port forward to Grafana
    if kubectl get service prometheus-grafana -n monitoring >/dev/null 2>&1; then
        kubectl port-forward service/prometheus-grafana 3000:80 -n monitoring &
        echo $! > tmp/pf-grafana.pid
    fi

    log_success "Port forwards established"
    log_info "Metrics: http://localhost:8080/metrics"
    log_info "Health: http://localhost:8081/healthz"
    log_info "Prometheus: http://localhost:9090"
    log_info "Grafana: http://localhost:3000 (admin/prom-operator)"
}

# Open monitoring dashboards
open_monitoring_dashboards() {
    log_info "Opening monitoring dashboards..."

    setup_port_forwards

    sleep 3

    if command_exists "${BROWSER}"; then
        "${BROWSER}" "http://localhost:8080/metrics" >/dev/null 2>&1 &
        "${BROWSER}" "http://localhost:9090" >/dev/null 2>&1 &
        "${BROWSER}" "http://localhost:3000" >/dev/null 2>&1 &
    fi

    log_success "Dashboards opened in browser"
}

# Inspect resources
inspect_resources() {
    log_header "Inspecting Resources"

    echo -e "${BLUE}CRDs:${NC}"
    kubectl get crd | grep neo4j

    echo -e "\n${BLUE}Neo4j Clusters:${NC}"
    kubectl get neo4jenterpriseclusters --all-namespaces

    echo -e "\n${BLUE}Neo4j Databases:${NC}"
    kubectl get neo4jdatabases --all-namespaces

    echo -e "\n${BLUE}Neo4j Backups:${NC}"
    kubectl get neo4jbackups --all-namespaces

    echo -e "\n${BLUE}Operator Pods:${NC}"
    kubectl get pods -l app.kubernetes.io/name=neo4j-operator --all-namespaces
}

# Clean development environment
clean_dev_env() {
    log_header "Cleaning Development Environment"

    # Stop port forwards
    for pid_file in tmp/pf-*.pid; do
        if [[ -f "$pid_file" ]]; then
            local pid=$(cat "$pid_file")
            kill "$pid" 2>/dev/null || true
            rm "$pid_file"
        fi
    done

    # Clean temporary files
    rm -rf tmp/* logs/*.log coverage/*

    # Clean Docker images
    docker image prune -f

    # Clean Go cache
    go clean -cache -modcache

    log_success "Development environment cleaned"
}

# Configuration menu
configure_dev_env() {
    log_header "Development Environment Configuration"

    load_config

    echo -e "${CYAN}Current Configuration:${NC}"
    echo "  Dev Mode: ${DEV_MODE:-development}"
    echo "  Debug Enabled: ${DEBUG_ENABLED:-false}"
    echo "  Hot Reload: ${HOT_RELOAD_ENABLED:-false}"
    echo "  Webhooks: ${WEBHOOKS_ENABLED:-false}"
    echo "  Cluster: ${CLUSTER_NAME:-neo4j-operator-dev}"
    echo "  Namespace: ${CLUSTER_NAMESPACE:-default}"

    echo -e "\n${BLUE}Configuration Options:${NC}"
    echo "1. Change development mode"
    echo "2. Toggle debug mode"
    echo "3. Toggle hot reload"
    echo "4. Toggle webhooks"
    echo "5. Change cluster settings"
    echo "6. Reset to defaults"
    echo "7. Save and exit"

    read -p "Choose option (1-7): " choice

    case $choice in
        1)
            echo "Development modes: development, debug, hot-reload, tilt"
            read -p "Enter mode: " DEV_MODE
            ;;
        2)
            DEBUG_ENABLED=$([[ "${DEBUG_ENABLED:-false}" == "true" ]] && echo "false" || echo "true")
            log_info "Debug mode: ${DEBUG_ENABLED}"
            ;;
        3)
            HOT_RELOAD_ENABLED=$([[ "${HOT_RELOAD_ENABLED:-false}" == "true" ]] && echo "false" || echo "true")
            log_info "Hot reload: ${HOT_RELOAD_ENABLED}"
            ;;
        4)
            WEBHOOKS_ENABLED=$([[ "${WEBHOOKS_ENABLED:-false}" == "true" ]] && echo "false" || echo "true")
            log_info "Webhooks: ${WEBHOOKS_ENABLED}"
            ;;
        5)
            read -p "Cluster name [${CLUSTER_NAME}]: " new_cluster_name
            CLUSTER_NAME="${new_cluster_name:-$CLUSTER_NAME}"
            read -p "Namespace [${CLUSTER_NAMESPACE}]: " new_namespace
            CLUSTER_NAMESPACE="${new_namespace:-$CLUSTER_NAMESPACE}"
            ;;
        6)
            rm -f "${DEV_CONFIG_FILE}"
            log_info "Configuration reset to defaults"
            return
            ;;
        7)
            save_config
            return
            ;;
        *)
            log_error "Invalid choice"
            ;;
    esac

    save_config
    configure_dev_env
}

# Stop development environment
stop_dev_env() {
    log_header "Stopping Development Environment"

    # Stop any running processes
    pkill -f "air\|dlv\|tilt" || true

    # Stop port forwards
    for pid_file in tmp/pf-*.pid; do
        if [[ -f "$pid_file" ]]; then
            local pid=$(cat "$pid_file")
            kill "$pid" 2>/dev/null || true
            rm "$pid_file"
        fi
    done

    log_success "Development environment stopped"
}

# Restart development environment
restart_dev_env() {
    stop_dev_env
    sleep 2
    start_dev_env
}

# Main function
main() {
    case "${1:-dashboard}" in
        "dashboard"|"status")
            show_dashboard
            ;;
        "init"|"setup")
            init_dev_env
            ;;
        "start"|"run")
            start_dev_env
            ;;
        "stop")
            stop_dev_env
            ;;
        "restart")
            restart_dev_env
            ;;
        "logs")
            view_logs
            ;;
        "test")
            run_tests "${2:-unit}"
            ;;
        "debug")
            debug_session
            ;;
        "config"|"configure")
            configure_dev_env
            ;;
        "clean")
            clean_dev_env
            ;;
        "tools")
            install_dev_tools
            ;;
        "help"|"-h"|"--help")
            show_help
            ;;
        *)
            log_error "Unknown command: $1"
            show_help
            exit 1
            ;;
    esac
}

# Show help
show_help() {
    echo -e "${CYAN}Neo4j Operator Development Environment Manager${NC}"
    echo
    echo "Usage: $0 [command] [options]"
    echo
    echo "Commands:"
    echo "  dashboard    Show development dashboard (default)"
    echo "  init         Initialize development environment"
    echo "  start        Start development environment"
    echo "  stop         Stop development environment"
    echo "  restart      Restart development environment"
    echo "  logs         View operator logs"
    echo "  test [type]  Run tests (unit, integration, e2e, all, coverage)"
    echo "  debug        Start interactive debug session"
    echo "  config       Configure development settings"
    echo "  clean        Clean development environment"
    echo "  tools        Install/update development tools"
    echo "  help         Show this help message"
    echo
    echo "Examples:"
    echo "  $0 init                    # Initialize development environment"
    echo "  $0 start                   # Start in normal mode"
    echo "  $0 test unit              # Run unit tests"
    echo "  $0 debug                  # Start debug session"
    echo "  $0 config                 # Configure settings"
}

# Run main function
main "$@"
